# 関数


\toc
<!-- パラメトリック制約可変長引数 -->






## 関数の基本
関数はJuliaの最重要キーワードです。
関数は引数の値を使い定義された処理をして結果の値を返します。

### 関数の定義
まずは`f`という名前の関数を
```
function f(x, y)
    x + y
end
```
のようにfunctionキーワードを使って定義するか、処理が簡潔な場合は一行で
```
f(x, y) = x + y
```
と定義できます。これは代入方式と呼ばれる関数の定義方法です。処理を一行で書くことが出来なくとも、複合文を使い
```
f(x, y) = begin
    # 複数行にわたって処理を書ける
    x + y
end
```
と書くことも出来ます。

変数名と同様にUnicodeが使えるので、
```
∑(x, y) = x + y
```
のように馴染みのある名前で関数を定義することも可能なうえ、
日本語の名前を使うことも出来ます。うれしいですね！

### 関数の呼び出し
定義済の関数は丸括弧を付け（引数がある場合は丸括弧内で指定し）、呼び出すことが出来ます。
```
f(2, 3)   # -> 5
```
上の通り`x=2`、`y=3`で`f`を呼び出すと上のように5が返されます。
（※以下、呼び出された関数が返す値はコメントにて`# -> 値`のように書くこととします。）
丸括弧を付けない場合は関数オブジェクトを表し、他の値と同じように受け渡しができます。
```
g = f
```
とすると`g`に`f`が代入され、
```
g(2, 3)   # -> 5
```
関数`f`と同じ処理をする関数`g`ができます。





## returnキーワード
関数は最後の計算結果を返します
```
function f(x, y)
    a = 2x
    b = y^2
    a*b
    a + b
end

f(2, 3)   # -> 13
```
が、`return`キーワードを使うと、`return`の直後にある式の結果を返します。
```
function g(x, y)
    a = 2x
    b = y^2
    return a*b
    a + b
end

g(2, 3)   # -> 36
```
このとき、関数は値を返した時点で処理を終了します。この性質は
```
function hypot(x, y)
    x = abs(x)
    y = abs(y)
    if x > y
        r = y/x
        return x*sqrt(1 + r*r)
    end
    if y == 0
        return zero(x)
    end
    r = x/y
    return y*sqrt(1 + r*r)
end

hypot(3, 4)   # -> 5.0
```
のように処理が分岐して複数の返値パターンがあるようなケースで有用です。最初の条件`x > y`が真であれば`x*sqrt(1 + r*r)`までを計算して終了です。`if y == 0`以降は評価されません





## 演算子と関数の関係
### 演算子は関数だ！
Juliaの演算子は特殊な記法を持つ関数です。（`&&`や`||`のような例外もあります）
従って
```
1 + 2 + 3   # -> 6

+(1, 2, 3)   # -> 6
```
のように括弧をつけて呼び出す関数スタイルで計算することも出来ます。
前者のような中置記法で演算子を使用した場合、Julia内部では後者のような関数呼び出しが行われています。

また、関数としての演算子を変数に代入することも可能です。
```
f = +

f(1, 2, 3)   # -> 6

1 f 2   # エラー
```
しかし残念ながら変数に代入されるのは関数であるため、中置記法などの演算子用記法は受け継がれません。

### 特殊な名前の演算子
前項の`+`は演算子としての名前と関数としての名前が一致していましたが、演算子の中には両者が一致していない場合もあります。下記のような演算子たちです。

| 記法              | 呼び出される関数 |
| ----------------- | ---------------- |
| `[A B C ...]`     | hcat             |
| `[A; B; C; ...]`  | vcat             |
| `[A B; C D; ...]` | hvcat            |
| `A'`              | adjoint          |
| `A[i]`            | getindex         |
| `A[i] = x`        | setindex!        |
| `A.n`             | getproperty      |
| `A.n = x`         | setproperty!     |





## 無名関数
Juliaの関数は第一級オブジェクトです。変数に代入したり代入された変数から一般的な関数呼び出し構文で呼び出せます。また、関数自体を他の関数の引数や返値として使えます。

このような用途では関数をその場一度限りで使う事が多々あります。その場合、無名関数が役立ちます。
```
x -> x^2 + 2x - 1

function (x)
    x^2 + 2x - 1
end
```
以上の無名関数は1つの引数`x`をとり、`x^2 + 2x - 1`の結果を返します。

先述の通り、おもに「関数を引数にとる関数」の引数として使われる無名関数は、古くから例として用いられる`map`関数（配列の各要素に関数を適用しその各結果を要素に持つ新しい配列を返す）を例に取れば、
```
f(x) = x^2 + 2x - 1

map(f, [1, 3, -1])   # -> [2, 14, -2]

map(x -> x^2 + 2x - 1, [1, 3, -1])   # -> [2, 14, -2]
```
のように関数`f`を定義した場合と同じ処理を無名関数で行えます。無名関数を使えばプログラムの行数を節約出来るだけでなく、関数の名前を考える煩わしさから解放されます！
```
(x, y, z) -> 2x + y - z   # 複数の引数はタプルのように丸括弧で囲む

() -> 3   # 引数のない無名関数
```
複数の引数や引数のない無名関数もあります。（引数のない無名関数は遅延評価に使われるようです。）





## 複数の返値
### タプル
Juliaには`Tuple`（タプル）と呼ばれるデータ構造が組み込まれており、これは関数の引数と返値と密接に関係しています。タプルは複数のデータを格納できる「器」です。配列とは異なり変更不可能です（[イミュータブル](https://ja.wikipedia.org/wiki/イミュータブル)）。

タプルにはあらゆる値を格納でき、添字を使ってi番目の要素を読み出せます。
```
(1, 1+1)   # -> (1, 2)

(1,)   # -> (1,)
# コンマを付けないとタプルの中の"1"ではなくただの数値”1”扱い

x = (0.0, "hello", 6*7)

x[2]   # -> "hello"
# 2番目の要素を取得
```
中身のない丸括弧`()`は空のタプルです。

### 名前付きタプル
タプルには`NamedTuple`（名前付きタプル）と呼ばれる各要素に名前がついているバージョンがあります。添字のほかにドット+名前を使って要素を読み出せます。
```
x = (one=1, two=1+1)

x[2]   # -> 2

x.two   # -> 2
```

### 複数の返値
Juliaの関数は複数の値を1つのタプルで返します。それぞれの値はコンマで区切り、タプルのような丸括弧は省略可能です。
```
function foo(a, b)
    a+b, a*b
end

foo(2, 3)   # -> (5, 6)
```
関数が返したタプルは簡単に分解できます
```
x, y = foo(2, 3)

x   # -> 5

y   # -> 6
```





## Argument destructuring
The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. (x, y)) instead of just a symbol, then an assignment (x, y) = argument will be inserted for you:
```
minmax(x, y) = (y < x) ? (y, x) : (x, y)

range((min, max)) = max - min

range(minmax(10, 2))   # -> 8
```
Notice the extra set of parentheses in the definition of range. Without those, range would be a two-argument function, and this example would not work.





## 可変長引数
### 任意の数の引数をもつ関数
任意の数の引数をとる関数も定義できます。このような関数は可変長引数（varargs）関数と呼ばれます。引数の後ろに`...`（ドット3つ）をつけるとその引数は可変長引数になります。
```
f(args...) = args

f(1, 2, 3)   # -> (1, 2, 3)

f()   # -> ()
```
これは最もシンプルな例です。複数の引数が`args`に束縛され、`args`は関数内でタプルとして扱われます（引数が一つも無い場合は空のタプルが返ってくる）。
```
bar(a, b, x...) = (a, b, x)

bar(1,2)   # -> (1, 2, ())

bar(1,2,3)   # -> (1, 2, (3,))

bar(1,2,3,4,5,6)   # -> (1, 2, (3, 4, 5, 6))
```
こちらでは引数の最初の2つは`a`と`b`に束縛され、残りすべてが`x`に束縛されます。`x`には任意の数の引数が束縛されますが、`a`と`b`には1つの値が束縛されるため`bar`は最少で2つの引数をとる関数となります。

可変長引数で、引数の数を指定することも出来ます。この詳細はメソッドセクションの「制約付き可変長引数」にて説明します。

### 関数呼び出しにおける引数の展開
可変長引数関数を定義する場合とは逆に、関数を**呼び出す**際にタプルの後ろにsplat演算子`...`を付けるとタプルの各要素を関数に引数として渡すことが出来る。
```
x = (3, 4)

f(1, 2, x)   # -> (1, 2, (3, 4))

f(1, 2, x...)   # -> (1, 2, 3, 4)
```
前者は`x`を`...`で展開していないので（数値,数値,タプル）の3つの引数を関数が受け取っていますが、後者は展開したので4つの数値を渡した（`f(1, 2, 3, 4)`）場合と同じです。
```
x = [3, 4]

bar(1, 2, x...)   # -> (1, 2, (3, 4))

baz(a, b) = a + b

baz(x...)   # -> 7

baz(1, 2, x...)   # エラー
```
以上のように、splat演算子はタプルでなくてもイテラブル（後の項で登場）な引数なら展開でき、可変長引数関数でなくても使えます。ただし、通常の関数で使う場合は引数の数に注意が必要です（2引数関数に3つ以上の引数を渡すなど）。





## オプション引数
関数には同じ値ばかりが使われる引数があり、そのような引数に毎回値を渡すのは面倒です。そんなときにはオプション引数が有用です。

組み込み関数`join`を例にとってみましょう。この関数は複数の文字列`strings`を`delim`で区切って結合します。
```
function join(strings, delim="")
    # 中身は略
end
```
このように”引数=デフォルト値”と書きます。オプション引数は省略可能で、省略した場合はデフォルト値が使われます。`join`はデフォルトの区切り文字が`""`（空の文字列）になっているので、delimを省略した場合は区切らずに結合することになります。
```
strs = ("Julia", "is", "a", "programming", "language.")

join(strs, " ")   # -> "Julia is a programming language."

join(strs, ",")   # -> "Julia,is,a,programming,language."

join(strs)   # -> "Juliaisaprogramminglanguage."
```





## キーワード引数
従来の関数では、「関数を呼び出すときに渡したｎ番目の値」が「関数のｎ番目の引数」に拘束されます。しかし規模の大きな1つの関数を定義する場合、往々にして引数の多さが厄介になってきます。関数を呼び出すときに「ｎ番目の引数は何に使われる値だったかな？」といった混乱が生じる事も少なくありません。キーワード引数はこのような問題を解消してくれます。

Plots.jlパッケージの`plot`関数を例に見てみましょう。この関数はプロットされる線のスタイル・幅・色などを設定する多くのオプションを持っています。`width`と`color`のみを指定して呼び出す場合、下記のようになります。
```
function plot(x, y; style="solid", width=1, color="black")
    # 略
end

x = #plot可能な値
y = #plot可能な値

plot(x, y, width=2, color="red")

plot(x, y; color="red", width=2)
```
キーワード引数を持つ関数を定義するときはセミコロンで区切る必要がありますが、呼び出すときはコンマも使うことが出来ます。また、順番も自由に入れ替えることが出来ます（※通常の引数は順番通り）。





## Argument Passing Behavior
Julia function arguments follow a convention sometimes called "pass-by-sharing", which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable bindings (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as Arrays) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.

```
function g(x, y)::Int8
    return x * y
end;

typeof(g(1, 2))   # -> Int8
```
のように関数のあとに`::Type`を付けると指定した型で値を返します。Type Declarationsを参照。
